# üõ†Ô∏è Guia de Implementa√ß√£o - Migra√ß√£o Oracle 19c

## üìã **Pr√©-requisitos**

### **Ambiente de Desenvolvimento**
- Node.js 18+ instalado
- Oracle 19c configurado (conforme imagem)
- Oracle Instant Client instalado
- Git para controle de vers√£o
- Editor de c√≥digo (VS Code recomendado)

### **Configura√ß√£o Oracle (Baseada na Imagem)**
```
Host: localhost
Port: 1521
Database: xe
Username: system
Password: [conforme configurado]
Client: OraDB21Home1
```

---

## üöÄ **Passo a Passo da Implementa√ß√£o**

### **Etapa 1: Configura√ß√£o do Banco de Dados**

#### **1.1 Conectar ao Oracle como SYSTEM**
```sql
-- Conectar via SQL*Plus ou Oracle SQL Developer
sqlplus system/[sua_senha]@localhost:1521/xe
```

#### **1.2 Criar Usu√°rio da Aplica√ß√£o**
```sql
-- Criar usu√°rio espec√≠fico para o NovoProtocolo
CREATE USER protocolo_user IDENTIFIED BY "NovoProtocolo2025!";

-- Conceder privil√©gios necess√°rios
GRANT CONNECT TO protocolo_user;
GRANT RESOURCE TO protocolo_user;
GRANT CREATE SESSION TO protocolo_user;
GRANT CREATE TABLE TO protocolo_user;
GRANT CREATE SEQUENCE TO protocolo_user;
GRANT CREATE TRIGGER TO protocolo_user;
GRANT CREATE VIEW TO protocolo_user;
GRANT CREATE PROCEDURE TO protocolo_user;

-- Conceder quota no tablespace
ALTER USER protocolo_user QUOTA UNLIMITED ON USERS;

-- Verificar cria√ß√£o
SELECT username, account_status FROM dba_users WHERE username = 'PROTOCOLO_USER';
```

#### **1.3 Criar Estrutura de Tabelas**
```sql
-- Conectar como protocolo_user
CONNECT protocolo_user/NovoProtocolo2025!@localhost:1521/xe

-- Tabela de Usu√°rios
CREATE TABLE usuarios (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR2(100) NOT NULL,
    email VARCHAR2(100) UNIQUE NOT NULL,
    senha VARCHAR2(255) NOT NULL,
    perfil VARCHAR2(50) NOT NULL CHECK (perfil IN ('admin', 'usuario', 'visualizador')),
    ativo NUMBER(1) DEFAULT 1 CHECK (ativo IN (0, 1)),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices para performance
CREATE INDEX idx_usuarios_email ON usuarios(email);
CREATE INDEX idx_usuarios_perfil ON usuarios(perfil);

-- Trigger para updated_at
CREATE OR REPLACE TRIGGER trg_usuarios_updated_at
    BEFORE UPDATE ON usuarios
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

-- Tabela de Processos
CREATE TABLE processos (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    numero VARCHAR2(50) UNIQUE NOT NULL,
    assunto VARCHAR2(255) NOT NULL,
    descricao CLOB,
    status VARCHAR2(50) NOT NULL CHECK (status IN ('aberto', 'em_andamento', 'concluido', 'cancelado')),
    prioridade VARCHAR2(20) NOT NULL CHECK (prioridade IN ('baixa', 'media', 'alta', 'urgente')),
    usuario_id NUMBER REFERENCES usuarios(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices
CREATE INDEX idx_processos_numero ON processos(numero);
CREATE INDEX idx_processos_status ON processos(status);
CREATE INDEX idx_processos_usuario ON processos(usuario_id);
CREATE INDEX idx_processos_created ON processos(created_at);

-- Trigger
CREATE OR REPLACE TRIGGER trg_processos_updated_at
    BEFORE UPDATE ON processos
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

-- Tabela de Documentos
CREATE TABLE documentos (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    titulo VARCHAR2(255) NOT NULL,
    tipo VARCHAR2(50) NOT NULL,
    categoria VARCHAR2(100),
    arquivo_nome VARCHAR2(255),
    arquivo_path VARCHAR2(500),
    arquivo_size NUMBER,
    mime_type VARCHAR2(100),
    versao NUMBER DEFAULT 1,
    processo_id NUMBER REFERENCES processos(id),
    usuario_id NUMBER REFERENCES usuarios(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices
CREATE INDEX idx_documentos_tipo ON documentos(tipo);
CREATE INDEX idx_documentos_categoria ON documentos(categoria);
CREATE INDEX idx_documentos_processo ON documentos(processo_id);

-- Trigger
CREATE OR REPLACE TRIGGER trg_documentos_updated_at
    BEFORE UPDATE ON documentos
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

-- Tabela de Tramita√ß√£o
CREATE TABLE tramitacao (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    processo_id NUMBER REFERENCES processos(id) NOT NULL,
    origem VARCHAR2(100) NOT NULL,
    destino VARCHAR2(100) NOT NULL,
    observacoes CLOB,
    status VARCHAR2(50) NOT NULL CHECK (status IN ('enviado', 'recebido', 'devolvido')),
    usuario_id NUMBER REFERENCES usuarios(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices
CREATE INDEX idx_tramitacao_processo ON tramitacao(processo_id);
CREATE INDEX idx_tramitacao_status ON tramitacao(status);
CREATE INDEX idx_tramitacao_created ON tramitacao(created_at);

-- Trigger
CREATE OR REPLACE TRIGGER trg_tramitacao_updated_at
    BEFORE UPDATE ON tramitacao
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

-- Tabela de Encomendas
CREATE TABLE encomendas (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo VARCHAR2(50) UNIQUE NOT NULL,
    descricao VARCHAR2(255) NOT NULL,
    fornecedor VARCHAR2(100),
    valor NUMBER(10,2),
    status VARCHAR2(50) NOT NULL CHECK (status IN ('pendente', 'aprovado', 'entregue', 'cancelado')),
    data_pedido DATE,
    data_entrega DATE,
    usuario_id NUMBER REFERENCES usuarios(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices
CREATE INDEX idx_encomendas_codigo ON encomendas(codigo);
CREATE INDEX idx_encomendas_status ON encomendas(status);
CREATE INDEX idx_encomendas_data_pedido ON encomendas(data_pedido);

-- Trigger
CREATE OR REPLACE TRIGGER trg_encomendas_updated_at
    BEFORE UPDATE ON encomendas
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

-- Tabela de Prazos
CREATE TABLE prazos (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    titulo VARCHAR2(255) NOT NULL,
    descricao CLOB,
    data_inicio DATE NOT NULL,
    data_fim DATE NOT NULL,
    status VARCHAR2(50) NOT NULL CHECK (status IN ('ativo', 'vencido', 'concluido', 'cancelado')),
    prioridade VARCHAR2(20) NOT NULL CHECK (prioridade IN ('baixa', 'media', 'alta', 'urgente')),
    processo_id NUMBER REFERENCES processos(id),
    usuario_id NUMBER REFERENCES usuarios(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_prazos_datas CHECK (data_fim >= data_inicio)
);

-- √çndices
CREATE INDEX idx_prazos_data_fim ON prazos(data_fim);
CREATE INDEX idx_prazos_status ON prazos(status);
CREATE INDEX idx_prazos_processo ON prazos(processo_id);

-- Trigger
CREATE OR REPLACE TRIGGER trg_prazos_updated_at
    BEFORE UPDATE ON prazos
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

-- Tabela de Arquivo
CREATE TABLE arquivo (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR2(255) NOT NULL,
    tipo VARCHAR2(50) NOT NULL,
    categoria VARCHAR2(100),
    tags VARCHAR2(500),
    arquivo_path VARCHAR2(500),
    arquivo_size NUMBER,
    mime_type VARCHAR2(100),
    nivel_acesso VARCHAR2(50) DEFAULT 'publico' CHECK (nivel_acesso IN ('publico', 'restrito', 'confidencial')),
    usuario_id NUMBER REFERENCES usuarios(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices
CREATE INDEX idx_arquivo_tipo ON arquivo(tipo);
CREATE INDEX idx_arquivo_categoria ON arquivo(categoria);
CREATE INDEX idx_arquivo_nivel_acesso ON arquivo(nivel_acesso);

-- Trigger
CREATE OR REPLACE TRIGGER trg_arquivo_updated_at
    BEFORE UPDATE ON arquivo
    FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

-- Commit das altera√ß√µes
COMMIT;
```

#### **1.4 Inserir Dados Iniciais**
```sql
-- Usu√°rio administrador padr√£o
INSERT INTO usuarios (nome, email, senha, perfil) 
VALUES ('Administrador', 'admin@novoprotocolo.com', '$2b$10$hash_da_senha', 'admin');

-- Dados de exemplo para testes
INSERT INTO processos (numero, assunto, descricao, status, prioridade, usuario_id)
VALUES ('PROC-2025-001', 'Processo de Teste', 'Processo criado para testes iniciais', 'aberto', 'media', 1);

COMMIT;
```

---

### **Etapa 2: Configura√ß√£o do Projeto Backend**

#### **2.1 Criar Estrutura do Projeto**
```bash
# Criar diret√≥rio do backend
mkdir backend
cd backend

# Inicializar projeto Node.js
npm init -y

# Instalar depend√™ncias principais
npm install express cors helmet morgan dotenv bcryptjs jsonwebtoken
npm install oracledb multer joi express-rate-limit compression

# Instalar depend√™ncias de desenvolvimento
npm install -D @types/node @types/express @types/cors @types/bcryptjs
npm install -D @types/jsonwebtoken @types/multer typescript ts-node nodemon

# Criar tsconfig.json
npx tsc --init
```

#### **2.2 Configurar TypeScript**
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

#### **2.3 Configurar Package.json**
```json
// package.json (scripts)
{
  "scripts": {
    "dev": "nodemon src/app.ts",
    "build": "tsc",
    "start": "node dist/app.js",
    "test": "jest",
    "migrate": "node dist/scripts/migrate.js"
  }
}
```

#### **2.4 Configurar Vari√°veis de Ambiente**
```env
# .env
NODE_ENV=development
PORT=3001

# Oracle Database
DB_USER=protocolo_user
DB_PASSWORD=NovoProtocolo2025!
DB_CONNECT_STRING=localhost:1521/xe
DB_POOL_MIN=2
DB_POOL_MAX=10
DB_POOL_INCREMENT=1

# JWT
JWT_SECRET=seu_jwt_secret_muito_seguro_aqui
JWT_EXPIRES_IN=24h

# Upload
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=10485760

# CORS
CORS_ORIGIN=http://localhost:8081,http://localhost:8082
```

---

### **Etapa 3: Implementa√ß√£o do Backend**

#### **3.1 Configura√ß√£o da Conex√£o Oracle**
```typescript
// src/config/database.ts
import oracledb from 'oracledb';
import path from 'path';

// Configurar Oracle Instant Client (se necess√°rio)
// oracledb.initOracleClient({ libDir: 'C:\\oracle\\instantclient_21_3' });

interface DatabaseConfig {
  user: string;
  password: string;
  connectString: string;
  poolMin: number;
  poolMax: number;
  poolIncrement: number;
}

const dbConfig: DatabaseConfig = {
  user: process.env.DB_USER || 'protocolo_user',
  password: process.env.DB_PASSWORD || 'NovoProtocolo2025!',
  connectString: process.env.DB_CONNECT_STRING || 'localhost:1521/xe',
  poolMin: parseInt(process.env.DB_POOL_MIN || '2'),
  poolMax: parseInt(process.env.DB_POOL_MAX || '10'),
  poolIncrement: parseInt(process.env.DB_POOL_INCREMENT || '1')
};

export class DatabaseService {
  private static pool: oracledb.Pool;

  static async initialize(): Promise<void> {
    try {
      // Configurar formato de data padr√£o
      oracledb.outFormat = oracledb.OUT_FORMAT_OBJECT;
      
      // Criar pool de conex√µes
      this.pool = await oracledb.createPool({
        ...dbConfig,
        poolAlias: 'default'
      });
      
      console.log('‚úÖ Pool de conex√µes Oracle criado com sucesso');
      
      // Testar conex√£o
      await this.testConnection();
    } catch (error) {
      console.error('‚ùå Erro ao criar pool de conex√µes Oracle:', error);
      throw error;
    }
  }

  static async testConnection(): Promise<void> {
    const connection = await this.getConnection();
    try {
      const result = await connection.execute('SELECT SYSDATE FROM DUAL');
      console.log('‚úÖ Teste de conex√£o Oracle bem-sucedido:', result.rows?.[0]);
    } finally {
      await connection.close();
    }
  }

  static async getConnection(): Promise<oracledb.Connection> {
    if (!this.pool) {
      throw new Error('Pool de conex√µes n√£o inicializado');
    }
    return await this.pool.getConnection();
  }

  static async close(): Promise<void> {
    if (this.pool) {
      await this.pool.close();
      console.log('‚úÖ Pool de conex√µes Oracle fechado');
    }
  }

  // M√©todo utilit√°rio para executar queries com tratamento de erro
  static async executeQuery(
    sql: string, 
    binds: any = {}, 
    options: any = {}
  ): Promise<oracledb.Result<any>> {
    const connection = await this.getConnection();
    try {
      const result = await connection.execute(sql, binds, {
        autoCommit: true,
        ...options
      });
      return result;
    } finally {
      await connection.close();
    }
  }
}
```

#### **3.2 Modelo Base**
```typescript
// src/models/base.model.ts
import { DatabaseService } from '../config/database';
import oracledb from 'oracledb';

export abstract class BaseModel {
  protected static tableName: string;

  static async findAll(filters: any = {}, pagination: any = {}): Promise<any[]> {
    const { page = 1, limit = 10 } = pagination;
    const offset = (page - 1) * limit;

    let sql = `SELECT * FROM ${this.tableName}`;
    const binds: any = {};
    const conditions: string[] = [];

    // Aplicar filtros dinamicamente
    Object.keys(filters).forEach((key, index) => {
      if (filters[key] !== undefined && filters[key] !== null) {
        conditions.push(`${key} = :filter${index}`);
        binds[`filter${index}`] = filters[key];
      }
    });

    if (conditions.length > 0) {
      sql += ` WHERE ${conditions.join(' AND ')}`;
    }

    sql += ` ORDER BY created_at DESC`;
    sql += ` OFFSET ${offset} ROWS FETCH NEXT ${limit} ROWS ONLY`;

    const result = await DatabaseService.executeQuery(sql, binds);
    return result.rows || [];
  }

  static async findById(id: number): Promise<any | null> {
    const sql = `SELECT * FROM ${this.tableName} WHERE id = :id`;
    const result = await DatabaseService.executeQuery(sql, { id });
    return result.rows?.[0] || null;
  }

  static async create(data: any): Promise<any> {
    const fields = Object.keys(data);
    const values = fields.map(field => `:${field}`);
    
    const sql = `
      INSERT INTO ${this.tableName} (${fields.join(', ')}) 
      VALUES (${values.join(', ')}) 
      RETURNING id INTO :id
    `;

    const binds = {
      ...data,
      id: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER }
    };

    const result = await DatabaseService.executeQuery(sql, binds);
    const newId = result.outBinds?.id?.[0];
    
    return await this.findById(newId);
  }

  static async update(id: number, data: any): Promise<any> {
    const fields = Object.keys(data);
    const setClause = fields.map(field => `${field} = :${field}`).join(', ');
    
    const sql = `UPDATE ${this.tableName} SET ${setClause} WHERE id = :id`;
    const binds = { ...data, id };

    await DatabaseService.executeQuery(sql, binds);
    return await this.findById(id);
  }

  static async delete(id: number): Promise<boolean> {
    const sql = `DELETE FROM ${this.tableName} WHERE id = :id`;
    const result = await DatabaseService.executeQuery(sql, { id });
    return (result.rowsAffected || 0) > 0;
  }

  static async count(filters: any = {}): Promise<number> {
    let sql = `SELECT COUNT(*) as total FROM ${this.tableName}`;
    const binds: any = {};
    const conditions: string[] = [];

    Object.keys(filters).forEach((key, index) => {
      if (filters[key] !== undefined && filters[key] !== null) {
        conditions.push(`${key} = :filter${index}`);
        binds[`filter${index}`] = filters[key];
      }
    });

    if (conditions.length > 0) {
      sql += ` WHERE ${conditions.join(' AND ')}`;
    }

    const result = await DatabaseService.executeQuery(sql, binds);
    return result.rows?.[0]?.TOTAL || 0;
  }
}
```

#### **3.3 Modelo de Processos**
```typescript
// src/models/processos.model.ts
import { BaseModel } from './base.model';
import { DatabaseService } from '../config/database';

export class ProcessosModel extends BaseModel {
  protected static tableName = 'processos';

  static async findWithUser(id: number): Promise<any | null> {
    const sql = `
      SELECT p.*, u.nome as usuario_nome, u.email as usuario_email
      FROM processos p
      LEFT JOIN usuarios u ON p.usuario_id = u.id
      WHERE p.id = :id
    `;
    
    const result = await DatabaseService.executeQuery(sql, { id });
    return result.rows?.[0] || null;
  }

  static async findAllWithUser(filters: any = {}, pagination: any = {}): Promise<any[]> {
    const { page = 1, limit = 10 } = pagination;
    const offset = (page - 1) * limit;

    let sql = `
      SELECT p.*, u.nome as usuario_nome, u.email as usuario_email
      FROM processos p
      LEFT JOIN usuarios u ON p.usuario_id = u.id
    `;
    
    const binds: any = {};
    const conditions: string[] = [];

    // Filtros espec√≠ficos
    if (filters.status) {
      conditions.push('p.status = :status');
      binds.status = filters.status;
    }
    
    if (filters.prioridade) {
      conditions.push('p.prioridade = :prioridade');
      binds.prioridade = filters.prioridade;
    }
    
    if (filters.search) {
      conditions.push('(UPPER(p.numero) LIKE UPPER(:search) OR UPPER(p.assunto) LIKE UPPER(:search))');
      binds.search = `%${filters.search}%`;
    }

    if (conditions.length > 0) {
      sql += ` WHERE ${conditions.join(' AND ')}`;
    }

    sql += ` ORDER BY p.created_at DESC`;
    sql += ` OFFSET ${offset} ROWS FETCH NEXT ${limit} ROWS ONLY`;

    const result = await DatabaseService.executeQuery(sql, binds);
    return result.rows || [];
  }

  static async getStatistics(): Promise<any> {
    const sql = `
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN status = 'aberto' THEN 1 ELSE 0 END) as abertos,
        SUM(CASE WHEN status = 'em_andamento' THEN 1 ELSE 0 END) as em_andamento,
        SUM(CASE WHEN status = 'concluido' THEN 1 ELSE 0 END) as concluidos,
        SUM(CASE WHEN status = 'cancelado' THEN 1 ELSE 0 END) as cancelados
      FROM processos
    `;
    
    const result = await DatabaseService.executeQuery(sql);
    return result.rows?.[0] || {};
  }
}
```

---

### **Etapa 4: Implementa√ß√£o dos Controllers**

#### **4.1 Controller Base**
```typescript
// src/controllers/base.controller.ts
import { Request, Response } from 'express';
import { BaseModel } from '../models/base.model';

export abstract class BaseController {
  protected static model: typeof BaseModel;

  static async getAll(req: Request, res: Response): Promise<void> {
    try {
      const { page = 1, limit = 10, ...filters } = req.query;
      
      const data = await this.model.findAll(
        filters, 
        { page: Number(page), limit: Number(limit) }
      );
      
      const total = await this.model.count(filters);
      const pages = Math.ceil(total / Number(limit));

      res.json({
        success: true,
        data,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total,
          pages
        }
      });
    } catch (error) {
      console.error('Erro ao buscar registros:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DATABASE_ERROR',
          message: 'Erro interno do servidor'
        }
      });
    }
  }

  static async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const data = await this.model.findById(Number(id));
      
      if (!data) {
        res.status(404).json({
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: 'Registro n√£o encontrado'
          }
        });
        return;
      }

      res.json({
        success: true,
        data
      });
    } catch (error) {
      console.error('Erro ao buscar registro:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DATABASE_ERROR',
          message: 'Erro interno do servidor'
        }
      });
    }
  }

  static async create(req: Request, res: Response): Promise<void> {
    try {
      const data = await this.model.create(req.body);
      
      res.status(201).json({
        success: true,
        data
      });
    } catch (error) {
      console.error('Erro ao criar registro:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DATABASE_ERROR',
          message: 'Erro interno do servidor'
        }
      });
    }
  }

  static async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const data = await this.model.update(Number(id), req.body);
      
      if (!data) {
        res.status(404).json({
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: 'Registro n√£o encontrado'
          }
        });
        return;
      }

      res.json({
        success: true,
        data
      });
    } catch (error) {
      console.error('Erro ao atualizar registro:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DATABASE_ERROR',
          message: 'Erro interno do servidor'
        }
      });
    }
  }

  static async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const success = await this.model.delete(Number(id));
      
      if (!success) {
        res.status(404).json({
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: 'Registro n√£o encontrado'
          }
        });
        return;
      }

      res.json({
        success: true,
        message: 'Registro exclu√≠do com sucesso'
      });
    } catch (error) {
      console.error('Erro ao excluir registro:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DATABASE_ERROR',
          message: 'Erro interno do servidor'
        }
      });
    }
  }
}
```

---

### **Etapa 5: Configura√ß√£o do Servidor Express**

#### **5.1 Aplica√ß√£o Principal**
```typescript
// src/app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import compression from 'compression';
import rateLimit from 'express-rate-limit';
import { config } from 'dotenv';
import path from 'path';

// Configurar vari√°veis de ambiente
config();

// Importar servi√ßos
import { DatabaseService } from './config/database';
import { apiRoutes } from './routes/api.routes';

const app = express();
const PORT = process.env.PORT || 3001;

// Middlewares de seguran√ßa
app.use(helmet());
app.use(compression());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // m√°ximo 100 requests por IP
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'Muitas requisi√ß√µes. Tente novamente em 15 minutos.'
    }
  }
});
app.use('/api', limiter);

// CORS
const corsOptions = {
  origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:8081', 'http://localhost:8082'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};
app.use(cors(corsOptions));

// Logging
app.use(morgan('combined'));

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Servir arquivos est√°ticos (uploads)
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Rotas da API
app.use('/api', apiRoutes);

// Rota de health check
app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'NovoProtocolo API est√° funcionando',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// Middleware de tratamento de erros
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Erro n√£o tratado:', err);
  
  res.status(err.status || 500).json({
    success: false,
    error: {
      code: err.code || 'INTERNAL_ERROR',
      message: process.env.NODE_ENV === 'production' 
        ? 'Erro interno do servidor' 
        : err.message
    }
  });
});

// Rota 404
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    error: {
      code: 'NOT_FOUND',
      message: 'Endpoint n√£o encontrado'
    }
  });
});

// Inicializar servidor
async function startServer() {
  try {
    // Inicializar conex√£o com Oracle
    await DatabaseService.initialize();
    
    // Iniciar servidor
    app.listen(PORT, () => {
      console.log(`üöÄ Servidor rodando na porta ${PORT}`);
      console.log(`üì° API dispon√≠vel em http://localhost:${PORT}/api`);
      console.log(`üè• Health check em http://localhost:${PORT}/health`);
    });
  } catch (error) {
    console.error('‚ùå Erro ao iniciar servidor:', error);
    process.exit(1);
  }
}

// Tratamento de sinais de encerramento
process.on('SIGINT', async () => {
  console.log('\nüõë Encerrando servidor...');
  await DatabaseService.close();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\nüõë Encerrando servidor...');
  await DatabaseService.close();
  process.exit(0);
});

// Iniciar aplica√ß√£o
startServer();

export default app;
```

---

### **Etapa 6: Scripts de Migra√ß√£o**

#### **6.1 Script de Migra√ß√£o de Dados**
```typescript
// src/scripts/migrate-data.ts
import { DatabaseService } from '../config/database';

// Dados do localStorage (exemplo)
const mockData = {
  usuarios: [
    {
      nome: 'Administrador',
      email: 'admin@novoprotocolo.com',
      senha: '$2b$10$hash_da_senha',
      perfil: 'admin'
    }
  ],
  processos: [
    {
      numero: 'PROC-2025-001',
      assunto: 'Processo Migrado',
      descricao: 'Processo migrado do sistema anterior',
      status: 'aberto',
      prioridade: 'media',
      usuario_id: 1
    }
  ]
  // ... outros dados
};

async function migrateData() {
  try {
    console.log('üîÑ Iniciando migra√ß√£o de dados...');
    
    await DatabaseService.initialize();
    
    // Migrar usu√°rios
    for (const usuario of mockData.usuarios) {
      const sql = `
        INSERT INTO usuarios (nome, email, senha, perfil)
        VALUES (:nome, :email, :senha, :perfil)
      `;
      await DatabaseService.executeQuery(sql, usuario);
    }
    
    // Migrar processos
    for (const processo of mockData.processos) {
      const sql = `
        INSERT INTO processos (numero, assunto, descricao, status, prioridade, usuario_id)
        VALUES (:numero, :assunto, :descricao, :status, :prioridade, :usuario_id)
      `;
      await DatabaseService.executeQuery(sql, processo);
    }
    
    console.log('‚úÖ Migra√ß√£o conclu√≠da com sucesso!');
  } catch (error) {
    console.error('‚ùå Erro na migra√ß√£o:', error);
  } finally {
    await DatabaseService.close();
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  migrateData();
}

export { migrateData };
```

---

## üß™ **Testes**

### **Teste de Conex√£o**
```bash
# Testar conex√£o Oracle
node -e "
const oracledb = require('oracledb');
oracledb.getConnection({
  user: 'protocolo_user',
  password: 'NovoProtocolo2025!',
  connectString: 'localhost:1521/xe'
}).then(conn => {
  console.log('‚úÖ Conex√£o OK');
  return conn.close();
}).catch(err => {
  console.error('‚ùå Erro:', err.message);
});
"
```

### **Teste das APIs**
```bash
# Testar health check
curl http://localhost:3001/health

# Testar login
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@novoprotocolo.com","senha":"admin123"}'

# Testar listagem de processos
curl -H "Authorization: Bearer SEU_TOKEN" \
  http://localhost:3001/api/processos
```

---

## üöÄ **Deploy**

### **Configura√ß√£o de Produ√ß√£o**
```bash
# Build do projeto
npm run build

# Instalar PM2 para gerenciamento de processos
npm install -g pm2

# Configurar PM2
echo '{
  "name": "novoprotocolo-api",
  "script": "dist/app.js",
  "instances": "max",
  "exec_mode": "cluster",
  "env": {
    "NODE_ENV": "production",
    "PORT": 3001
  }
}' > ecosystem.config.json

# Iniciar aplica√ß√£o
pm2 start ecosystem.config.json
```

---

**üéØ Este guia fornece todos os passos necess√°rios para implementar a migra√ß√£o completa do sistema mock para Oracle 19c com APIs REST robustas e seguras.**